services:
  # Serviço do Servidor Web Nginx
  web:
    # Usei 'build' em vez de 'image' para poder adicionar o entrypoint.sh e outras configurações
    build:
      context: ./nginx # Indica onde está o Dockerfile para construir a imagem do Nginx
      dockerfile: Dockerfile # O nome do Dockerfile que você criou (em ./nginx/Dockerfile)
    # image: nginx:latest # REMOVA OU COMENTE esta linha, pois agora a imagem foi criada
    container_name: safe-chat_nginx_server
    ports:
      - "80:80"   # Mapeia a porta HTTP para redirecionar para HTTPS
      - "443:443" # Mapeia a porta HTTPS
    volumes:
      # Mapeia o seu nginx.conf customizado para o contêiner
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      # Mapeia a pasta de certificados do backend para dentro do contêiner Nginx
      # Assim, o Nginx pode acessar server.crt e server_key.pem (com senha)
      - ./safechat-backend/app/ssl/server:/etc/nginx/certs:ro
      # NÃO PRECISAMOS mapear o entrypoint.sh aqui, pois ele será COPIADO pelo Dockerfile
    environment:
      # Injeta a senha da chave privada do Nginx como uma variável de ambiente
      SERVER_KEY_PASSPHRASE: ${SERVER_KEY_PASSWORD_NGINX} # A senha virá do seu arquivo .env principal    
    networks:
      - sc-network
    depends_on:
      backend-app:
        condition: service_healthy # Nginx AGORA espera que o backend-app esteja saudável
      frontend-app: # NOVO: Nginx também espera que o frontend-app esteja saudável
        condition: service_healthy



  # Serviço da Aplicação Frontend (Python Flask)
  frontend-app:      # <<-- AQUI REFERE-SE NOME DO SERVIÇO
    build: ./safechat-front/app # Caminho para o Dockerfile do frontend
    container_name: sc-flask_frontend
    # Linhas 'env_file:' removidas daqui, pois as variáveis virão do .env da raiz.
    environment:
      DB_HOST: db # O nome do serviço do banco de dados no Docker Compose
      DB_USER: ${MYSQL_USER}
      DB_PASSWORD: ${MYSQL_PASSWORD}
      DB_NAME: ${MYSQL_DATABASE}
      FLASK_SECRET_KEY_FRONTEND: ${FLASK_SECRET_KEY_FRONTEND} # Chave secreta para o Flask frontend (app.py)
    networks:
      - sc-network
    volumes:
      - ./safechat-front/app:/app # Monta o código do frontend no contêiner
      - ./safechat-front/app/static/images/uploads:/app/static/images/uploads
      - ./safechat-front/app/uploads:/app/uploads # Adicione esta linha se você usa esta pasta
    depends_on:
      db:
        condition: service_healthy # Frontend depende do DB estar saudável
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/"] # Corrigido: Porta 8000 para o Gunicorn do frontend
      interval: 10s
      timeout: 10s
      retries: 5
      start_period: 30s # Tempo para o serviço iniciar antes de começar a checagem



  # Serviço da Aplicação Backend (Python Flask-SocketIO com Criptografia)
  backend-app:    # <<-- AQUI REFERE-SE NOME DO SERVIÇO
    build: ./safechat-backend/app # Caminho para o Dockerfile do backend
    container_name: sc-python_app
    env_file:
      - ./safechat-backend/app/.env # Variáveis de ambiente específicas do backend (ex: SERVER_KEY_PASSWORD) - MANTIDO
      # A linha de env_file do DB foi removida aqui se as variáveis do DB estiverem no .env da raiz
    environment:
      DB_HOST: db
      DB_USER: ${MYSQL_USER}
      DB_PASSWORD: ${MYSQL_PASSWORD}
      DB_NAME: ${MYSQL_DATABASE}
      FLASK_SECRET_KEY_BACKEND: ${FLASK_SECRET_KEY_BACKEND} # Chave secreta para o Flask backend (app.py)
    # REMOVIDA a porta 8000 daqui, pois o Nginx fará o proxy
    # ports:
    #   - "8000:8000"    
    networks:
      - sc-network
    volumes:
      - ./safechat-backend/app:/app
      - ./safechat-backend/app/ssl:/app/ssl:ro
      - ./safechat-backend/app/static/images/uploads:/app/static/images/uploads
    depends_on:
      db:
        condition: service_healthy
    healthcheck:
    # O healthcheck do backend agora deve apontar para o Gunicorn via HTTP,
      # já que o SSL será terminado no Nginx.
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]   #removi o SSL do Gunicorn do backend, então ele está a escutar em HTTP. 
      interval: 10s                                                 # Verifique se /health é o endpoint correto   VERIFICARRRRRRRR
      timeout: 10s
      retries: 5
      start_period: 30s
    # Adicione ou modifique o 'command' para o Gunicorn não usar SSL
    command: gunicorn -w 4 -k eventlet -b 0.0.0.0:8000 wsgi:app # Gunicorn sem SSL



  # Serviço do Banco de Dados MySQL
  db:
    image: mysql:latest
    container_name: sc-mysql_db
    # Linhas 'env_file:' removidas daqui, pois as variáveis virão do .env da raiz.
    environment: # Variáveis ESSENCIAIS para a imagem MySQL
      MYSQL_ROOT_PASSWORD: ${MYSQL_PASSWORD}
      MYSQL_DATABASE: ${MYSQL_DATABASE}
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
    volumes:
      - db_data:/var/lib/mysql
      - ./safechat-backend/db/init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    ports:
      - "3308:3306"
    networks:
      - sc-network
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-u$$MYSQL_USER", "-p$$MYSQL_PASSWORD"]
      interval: 10s
      timeout: 10s
      retries: 10
      start_period: 30s

networks:
  sc-network:
    driver: bridge

volumes:
  db_data: